CHAPITRE 13
-----------
CREER UNE APPLICATION DESKTOP
-----------------------------

Dans ce chapitre, on discutera des points importants et des techniques permettant de créer des applications Desktop qui utilisent la Toolbox du IIGS. De plus, on parlera dans le contexte d'un exemple d'application GS DEMO.BAS, des fonctions et des instructions du language TML BASIC qui permettent d'implanter des programmes Desktop.

Les applications Desktop sont l'un des types de programmes les plus avancés que vous pouvez créer pour le IIGS. Non seulement il faut de bonnes compétences en programmation, mais une très bonne compréhension de la toolbox du IIGS, et plus particulièrement pour les ensembles d'outils du Desktop.

Ce chapitre sert seulement d'introduction à la création des applications Desktop. Bien que nous ferons attention à certains détails pour l'utilisation de certaines routines de la Toolbox et plus spécialement à celles utilisées pour créer des menus et des fenetres, on ne décrira pas la façon dont fonctionne toutes les routines de la Toolbox. Le livre IIGS TOOLBOX REFERENCE, est la référence absolue pour la Toolbox et quiconque essaie d'écrire des programmes dépassant les simples programmes de base s'apercevront que cet ouvrage est nécessaire.

L'appendice C fournie une liste complète des librairies Toolbox fournies avec TML BASIC et le chapitre 11 décrit l'utilisation des librairies dans un programme.

L'INTERFACE DESKTOP
-------------------
L'interface Desktop Apple est un ensemble d'idées générales sur l'interface humaine, développée par Apple Computer, qui définie le visuel et le sensitif (look and feel) des applications utilisant la Toolbox du IIGS. Le look and feel d'une application représente la communication entre l'ordinateur et l'utilisateur. 

Le but des idées générales est de créer un comportement standard pour les applications, qui soit accessible, non menaçant et qui ait un comportement prévisible pour l'utilisateur. Les applications qui suivront finalement ces idées générales seront familières à l'utilisateur et ainsi auront du succès de façon beaucoup plus probable.

L'ensemble complet des idées générales est documenté dans le livre publié par Apple Computer : The Human Guidelines (Idées générales sur l'interface humaine).

IDEES GENERALES SUR L'INTERFACE HUMAINE
---------------------------------------
Suit un bref résumé des principes que l'on trouve dans Human Guidelines. Si vous prévoyez d'écrire une application Desktop, les idées générales devraient etre suivies de telle façon que quelque soit les fonctionnalités de votre programme, il communiquera avec l'utilisateur de façon constante et standard.

<page-footer>
<page-break>

Page 356
Metaphores d'après le monde réel.
Utiliser des métaphores concrètes et faites les simples de telle façon que l'utilisateur puisse attendre un certain nombre de choses de l'environnement de l'ordinateur et à chaque fois que c'est approprié, utilisez des effets visuels et sonores, qui aideront à mieux faire passer le message de la métaphore.

La manipulation directe.
Les utilisateurs veulent sentir qu'ils sont pris en charge par les activités de l'ordinateur. Ils s'attendent à ce que leurs actions aient des résultats et donc les outils devraient fournir une information en retour à leurs actions.

Voir-et-pointer au lieu de se-souvenir-et-taper.
L'utilisateur choisi une action parmis un choix de plusieurs actions affichées à l'écran. L'utilisateur se base sur la reconnaissance et non pas sur le souvenir. L'utilisateur ne devrait pas avoir à se souvenir de quoique ce soit que l'ordinateur connait déjà. 

La constance.
Les applications efficaces sont constantes à l'intérieur d'elles memes et constantes en regard des autres applications. Une application devrait développer un mécanisme standard pour la manipulation des objets. Si certaines opérations sont communes à plusieurs applications (Couper, copier, coller), le mécanisme pour utiliser ces opérations devrait le meme.

WYSIWYG - What You See Is What You Get.
(CQVVECQVO - Ce Que Vous Voyez Est Ce Que Vous Obtenez)
Il ne devrait pas y avoir de secret pour les utilisateurs, pas de commande abstraite dont le résultat n'est pas tout à fait certain. Il ne devrait pas y avoir de différence significative entre ce que l'utilisateur voit sur l'écran et ce qui est finallement imprimé.

Les actions laissées à l'initiative de l'utilisateur.
L'utilisateur et non pas l'ordinateur, initie et controle toutes les actions.

L'information en retour et le dialogue.
Maintenez l'utilisateur informé et donnez une information en retour, suite à chacune de ses actions.

Le pardon.
Les utilisateurs font des erreurs, pardonnez leur.

Stabilitée perçue.
Les utilisateurs se sentent à l'aise dans un environnement d'ordinateur qui reste compréhensible et familier, plutot que dans un environnement qui change de façon aléatoire.

L'intégrité esthétique.
Des affichages confus ou non attractifs otent de l'efficacité à l'interaction etre humain-ordinateur. Il devrait etre permis aux utilisateurs de controler l'apparence superficielle de ce qu'ils voient sur l'écran, pour afficher leur propre style et leur propre individualité.
<page-footer>
<page-break>

Page 357
LES ELEMENTS DU DESKTOP
-----------------------
Pour gérer les principes définis par les idées générales de l'interface humaine, Apple a défini deux classes d'éléments d'interface standard, pour l'interface Apple Desktop.

Les éléments écrans, définissant le coté visuel de l'interface

Les intéractions homme-ordinateur qui sont le coté sensitif de l'interface.

Les éléments écran fournissent le contexte visuel de base pour les applications. Il y a trois éléments écran fondamentaux. Le Desktop, les fenetres et les menus. (Voir figure 13-1). Le Desktop établi la métaphore pour l'interface. Le bureau (Desktop) est la surface sur laquelle les autres éléments de l'interface sont placés. Une fenetre est une trame pour visualiser les objets qu'une application manipule. Les fenetres dans le finder du IIGS sont utilisées pour voir des fichiers et des répertoires sur un disque, alors que des fenetres en TML BASIC sont utilisées pour voir des fichiers texte qui contiennent du code source basic. Enfin, les menus déroulants fournissent le mécanisme central permettant à l'utilisateur de commander à une application d'éxecuter une opération. Les menus cachent les détails d'une application, mais en meme temps rendent ces détails rapides et accessibles aisement.

Figure 13-1 : Le Finder Desktop
Se reporter à la documentation papier du TML BASIC

La manipulation directe par l'utilisateur, est ce qu'il y a de plus important pour l'interaction etre humain-ordinateur. Un système permettant de pointer vers quelque chose, comme la souris, permets à l'utilisateur de controler directement les objets qui sont sur le bureau. L'utilisateur peux pointer vers des objets sur l'écran, les choisir avec un click-souris, les déplacer et choisir les actions qui s'appliquent aux objets choisis.
<page-footer>
<page-break>

Page 358
Le clavier fait également partie de l'interaction entre l'utilisateur et l'ordinateur. Alors que le clavier est principalement utilisé pour rentrer des données, il peut également fournir des alternatives pour le déplacement ou le choix des objets.

LES PROGRAMMES CONTROLES PAR LES EVENEMENTS
-------------------------------------------
L'ecriture de programmes qui gèrent le bureau et qui fournissent des possibilités de manipulation directe, nécessitent un style de programmation différent de celui auquel vous pouvez etre habitué.

Autrefois, les programmes d'ordinateur étaient éxécutés en mode Batch (par lot de cartes). Une pile de cartes était rentrée à l'intérieur de l'ordinateur, celui ci traitait les cartes les unes après les autres, dans le meme ordre, à chaque fois que le programme était lancé. Ensuite, il y a eu les terminaux d'ordinateur. Les utilisateurs pouvaient alors intéragir avec un programme pendant que ce dernier s'éxécutait. Le programme permettait aux utilisateurs d'envoyer des commandes affectant la façon dont le programme était éxécuté. Pendant que l'utilisateur interragissait avec le programme, celui ci controlait malgré tout les choix et l'ordre dans lequel les opérations étaient éxécutées. L'utilisateur était donc encore controlé par le programme.

La programmation dirigée par des évenements, avec l'interface Desktop Apple, est à l'opposé de ces façons traditionnelles de programmer. La programmation dirigée par des évenements signifie, simplement, que c'est l'utilisateur qui a le controle, et non le programme. Le principe de base de la programmation dirigée par des évenements est qu'il y a de nombreux choix, à tout moment disponible pour l'utilisateur, et l'utilisateur controle l'ordre dans lequel les opérations seront éxécutées. Par exemple, l'utilisateur peut réaliser des opérations à partir des menus déroulants, ouvrir ou fermer des fenetres, ou travaille, comme par exemple utiliser un traitement de texte, ou faire des dessins. Avec quelques exceptions, toutes ces opérations sont disponibles en meme temps. C'est à dire que le programme est sans modèle.

Les activités provoquant ces actions sont appelées des évenements (events). Des évenements peuvent par exemple etre l'enfoncement d'une touche, le click-souris, l'insertion d'un disque dans un lecteur de disquette, des données arrivant sur un port série, ou des évenements gènérés par le programme lui-meme.

LA BOUCLE D'EVENEMENT PRINCIPAL
-------------------------------
La structure de base d'un programme dirigé par les évenements, est en fait tout à fait simple. Le programme passe la plupart de son temps dans une boucle appelée MAIN EVENT LOOP (boucle d'evenement principal). La seule activitée éxécutée dans cette boucle est l'attente d'un évenement. Quand un évenement arrive, la boucle décide quel type d'évenement est arrivé, et entreprends l'action appropriée.

La figure 13-2 présente une représentation conceptuelle du déroulement de l'éxécution dans un programme dirigé par les évenements écrit en TML BASIC. Un programme contient une simple boucle qui appele répétitivement l'instruction TASKPOLL. A chaque fois que l'instruction TASKPOLL est éxécutée, elle examine la file d'attente des évenements (event queue) pour voir si un évenement quelconque est arrivé. Si oui, l'évenement est retiré de la file d'attente et envoyé à un sous programme de gestion d'évenements. Ce sous programme est choisi dans le tableau de répartition de direction des évenements (Event Dispatch Table).
<page-footer>
<page-break>

Page 359
Figure 13-2 : Main Event Loop
Se reporter à la documentation papier du TML BASIC

LA GESTION DES EVENEMENTS
-------------------------
(Event Handling)
Il y a 29 types d'évenements différents couramment définis par la Toolbox. Chacun de ces évenements est détecté par l'instruction TASKPOLL. Le tableau 13-1 donne la liste de chacun de ces évenements. Les 16 premiers évenements (numérotés de 0 à 15) sont les évenements de l'Event Manager. Ces évenements sont les évenements de plus bas niveaux, et sont détectés par l'ensemble d'outils Event Manager. Les évenements numérotés 16 à 28, sont les évenements du Window Manager TaskMaster Events. Ce sont des évenements de haut niveaux, indiquant, par exemple, un évenement Souris appuyée, dans une partie spéciale du bureau, soit la fenetre, soit un menu. Ils représentent les valeurs de résultat du sous programme de la Toolbox FindWindow.

_____________________________________________________________________________

                      Table 13-1
            Types d'évenements de l'Event Manager

_____________________________________________________________________________


Code de 
de l'évenement      Signification       Description

0   Evenement nul   Renvoyé quand il n'y a pas d'autre évenement disponible  
    (NullEvent)
1   Souris appuyée  Généré quand l'utilisateur appuie sur le bouton de souris
    (Mouse-Down)
2   Souris relachée Généré quand l'utilisateur relache le bouton de la souris
    (Mouse-Up)
3   Touche enfoncée Généré quand l'utilisateur appuie sur une touche du           (Key-Down)      clavier, ou du pavé numérique. Les touches caractères                         comprennent toutes les touches, sauf les touches : SHIFT,                     CAPSLOCK, CONTROL, OPTION et APPLE, qui sont des touches                      modificatrices.
<page-footer>
<page-break>

Page 360
4   Non défini
5   Répétition      Généré quand l'utilisateur maintient une touche appuyée.
    touche          La répétition est générée après un certain temps initial,     (Auto-Key)      puis à intervals réguliers.
6   Mise à jour     Ceci est un évenement généré de façon interne, indiquant      (UpDate)        que le contenu d'une fenetre à besoin d'etre mis à jour.                      (redessiné).
7   Non défini
8   Active          Ceci est un évenement généré  de façon interne quand une 
    (Activate)      fenetre devient active ou inactive. C'est à dire quand la                     fenetre se déplace du fond vers le premier plan ou du 
                    premier plan vers le fond respectivement.
9   Contact         Généré quand un contact control est pressé.
    (Switch)
10  Accessoire de   Généré quand le menu Classic Desk Accesories (CDA) est
    bureau          appelé avec la séquence CTRL POMME ESC
    (Desk-Accessory)
11  Driver de       Généré quand un driver de périphérique éxécute un
    périphérique    post-évenement suite à certaines circonstances, le plus 
    (Device Driver) souvent quand il y a eu une transmission de données ou
                    quand une transmission de données a été interrompue.
12-15 Application   Il y a quatre générations différentes d'évenements                            définis par des applications. La signification de ces
                    évenements est définie par l'application et est rangée                        dans la file d'attente des évenements en utilisant
                    Post-event.
16  Dans le bureau  Un évenement Mouse-down est arrivé dans le Desktop (mais
    (InDesk)        pas dans une des fenetres)
17  Dans barre menu Un évenement Mouse-down est arrivé dans la barre des          (InMenuBar)     menus et ensuite a été relaché sur un élément de menu                         qui n'était pas un accessoire de bureau du menu pomme, 
                    ou d'un menu ajouté par un accessoire de bureau.
                    TaskMaster prends note de ce que fait la souris, jusqu'à
                    ce que le bouton ait été relaché sur un élément                               particulier de menu, ce qui permets de sélectionner
                    cet élément.
18  Dans fenetre    Un évenement Mouse-down est arrivé dans la fenetre            système         système.
    (InSysWindow)
19  Dans le contenu Un évenement Mouse-down est arrivé dans la région
    (InContent)     contenu d'une fenetre.
20  Tirer           Un évenement Mouse-down est arrivé dans la région pour
    (InDrag)        tirer d'une fenetre
21  Aggrandir       Un évenement Mouse-down est arrivé dans l'icone               (InGrow)        agrandissement d'une fenetre
22  S'en aller      Un évenement Mouse-down est arrivé dans la boite de 
    (InGoAway)      fermeture d'une fenetre
23  Dans le zoom    Un évenement Mouse-down est arrivé dans la boite Zoom
    (InZoom)        d'une fenetre
24  Dans Info       Un évenement Mouse-down est arrivé dans la barre              (InInfo)        d'information d'une fenetre
25  Non défini
26  Non défini
27  Dans le corps   Un évenement Mouse-down est arrivé dans le corps d'une
    (InFrame)       fenetre
28  Dans le menu    Meme chose que l'évenement InMenuBar, sauf que l'élément      spécial         de menu choisi était un élément de Fermer, Annuler,           (InSpecialMenu) Couper, Copier, Coller ou effacer, ce qui ne s'applique                       pas aux accessoires de bureau

_____________________________________________________________________________

Quand TASKPOLL détecte un évenement, le type d'évenement est utilisé comme un index dans une structure de données spéciale, gérée de façon interne par TML BASIC  - le tableau de distribution des évenements (Event Dispatch Table).
Le tableau contient les étiquettes pour les sous programmes qui gérent les évenements. Pour entrer une étiquette dans ce tableau, on utilise l'instruction EVENTDEF. Par exemple, l'instruction

   EVENTDEF 3,HandleKeyDown

entre l'étiquette HandleKeyDown, dans l'index 3 du tableau. Ainsi, quand TASKPOLL détecte un évenement touche appuyée, le sous programme HandleKeyDown est automatiquement appelé pour gérer l'évenement. Les sous routines de gestion d'évenements doivent se terminer avec l'instruction RETURN 0 plutot que l'instruction normale RETURN.
<page-footer>
<page-break>

Page 361
TML BASIC gère une seconde structure de données appelée tableau de répartition des éléments de menu (Menu Item Dispatch Tabble).
Ce tableau permets à un programme de spécifier les étiquettes vers des sous programmes qui gèrent chacun des éléments du menu dans un programme. Le tableau contient 128 entrées numérotées de 0 à 127, les labels des sous programmes sont entrés dans ce tableau en utilisant l'instruction MENUDEF. Par exemple, l'instruction :

   MENUDEF 6,DoAbout

entre le lable DoAbout dans l'index 6 du tableau. Ainsi, quand TASKPOLL détecte un évenement InMenuBar (évenement 17), ou un évenement InSpecialMenu (évenement 28) et qu'il n'a pas été spécifié de label de sous programme pour l'évenement, dans l'Event Dispatch Table, le sous programme approprié de gestion d'éléments de menu est appelé à l'aide du Menu Item Dispatch Table.

Comme indiqué plus loin dans ce chapitre, dans la partie "SetUpMenus", à chaque élément de menu, on donne un identificateur entier unique. Les identificateurs d'élément de menu sont compris dans la gamme 250 à 377. Ainsi, TASKPOLL enlève 250 de l'identificateur de l'élément de menu pour obtenir l'index dans le tableau Menu Item Dispatch Table.

Pour utiliser l'instruction TASKPOLL, un programme doit tout d'abord initialiser le traitement des évenements. Ceci est réalisé avec l'instruction TASKPOLL INIT. L'instruction a un argument, qui est la valeur TaskMask. TaskMask controle le type d'évenement que l'instruction TASKPOLL est autorisée à gérer. Comme noté précédemment, les 29 types d'évenements sont divisés en deux catégories: Event Manager et TaskMaster. Les évenements Event Manager sont les évenements à bas niveau qui sont toujours détectés. Toutefois, les évenements à haut niveau TaskMaster et d'autres opérations sont controlés par TaskMask. 

Les évenements TaskMaster sont détectés comme le résultat d'une analyse plus profonde d'un évenement Mouse-Down dans un menu, ou dans une fenetre. Puisque chaque programme de bureau contient des menus et des fenetres, la gestion d'evenements pour certains évenements Mouse-Down peut etre géré de façon standard. Par exemple, à chaque fois que le bouton de la souris est clické sur la barre de menu, on doit suivre la souris afin de dérouler des menus et de choisir un élément de menus. De plus, si un accessoire de bureau est choisi, l'accessoire de bureau doit etre ouvert. Le code pour réaliser cette opération peut etre fait de façon standard pour tous les programmes. TaskMaster (c'est à dire TASKPOLL) peut éxécuter ces opérations si vous lui demandez. Les opérations que TaskMaster devrait entreprendre sont spécifiées par la valeur de TaskMask dans l'instruction TASKPOLL INIT. Un masque est la somme de toutes les valeurs individuelles. Le tableau 13-2 donne la liste des valeurs de TaskMask.
<page-footer>
<page-break>

Page 362
_____________________________________________________________________________

                         Tableau 13-2
                Valeurs du masque de TASKPOLL INIT
_____________________________________________________________________________

Valeur    Description
1         Détecte une touche menu
2         Exécute une mise à jour automatique de fenetre
4         Execute FindWindow (recherche fenetre)
8         Execute MenuSelect (choix dans un menu)
16        Execute l'ouverture d'un NDA
32        Execute SystemClick
64        Execute DragWindow (tirer une fenetre)
128       Execute SelectWindow (choix de fenetre) si le bouton de souris est
          appuyé dans le contenu de la fenetre
256       Execute TrackGoAway
512       Execute TrackZoom
1024      Execute GrowWindow (agrandir la fenetre)
2048      Execute un support de défilement automatique (scrolling support)
4096      Gère les éléments du menu spécial (menu couper/coller etc)
_____________________________________________________________________________

Ainsi, une valeur de TaskMask de 8191 (la somme de chaque valeur) spécifie que TaskMaster devra exécuter tous les traitements possibles d'évenements de haut niveau.

Enfin, il est possible de filtrer certains évenements pour empecher qu'ils soient détectés, en utilisant l'argument EventMask de l'instruction TASKPOLL. Le tableau 13-3 contient la liste des valeurs de l'EventMask. Une fois encore, un masque complet d'évenement (Event Mask) est obtenu en ajoutant les valeurs individuelles. Bien sur, un programme devrait normallement traiter tous les évenements.
_____________________________________________________________________________

                         Tableau 13-3
               Valeurs du masque d'évenements de TASKPOLL

_____________________________________________________________________________

Valeur         Description
2              Bouton souris appuyé (Mouse Down)
4              Bouton souris relache (Mouse Up)
8              Touche appuyée (Key Down)
32             Répetition de touche (Auto Key)
64             Mise à jour (UpDate)
256            Activation (de fenetre) (Activate)
<page-footer>
<page-break>

Page 363
512            Contact (Switch)
1024           Accessoire de bureau (Desk Accessory)
2048           Driver de périphérique (Device Driver)
4096           Défini pour l'application numéro 1
8192           Défini pour l'application numéro 2
16384          Défini pour l'application numéro 3
-32768         Défini pour l'application numéro 4

_____________________________________________________________________________


Un masque d'évenement qui a pour valeur -1, indique que l'on ne filtre aucun élément.

UN EXEMPLE D'APPLICATION DESKTOP
--------------------------------
Le reste de ce chapitre est consacré à l'illustration des techniques de programmation pour les programmes controlés par des évenements, dans le contexte de l'interface Apple Desktop. Les discussions tourneront autour de l'exemple d'application GS.DEMO.BAS. Ce programme est une application Desktop simple qui a deux fenetres et quatre menus.

Le programme GS.DEMO.BAS utilise la librairie Desktools, que l'on trouve dans le sous répertoire LIBRARIES. La librairie Desktools contient plusieurs procédures et fonctions qui gèrent des opérations qui sont nécessitées par la plupart des applications Desktop. Le code source complet de la librairie est inclu, de telle façon que vous puissiez changer son comportement comme il convient pour votre propre application.

Avant de continuer, vous devriez compiler ce programme et l'essayer, afin de mieux apprecier le code necessaire pour créer chaque élément du programme.

LA LIBRAIRIE DESKTOOLS
----------------------
Plusieurs opérations relatives aux applications Desktop, doivent etre gérées dans le code source de chaque programme Desktop. Ces applications comprennent le chargement et l'initialisation des ensembles d'outils de la toolbox du IIGS, utilisés par l'application, la création de menus et de fenetres et enfin, la procédure de mise hors service (Shutdown) des ensembles d'outils, quand le programme est terminé. Puisque ces opérations sont quasimment identiques dans tous les programmes, TML BASIC vous donne le code source total pour une librairie de procédures et de fonctions qui gèrent ces taches. C'est cette librairie DESKTOOLS.BAS qui se trouve dans le sous-répertoire LIBRARIES du disque de distribution.

Suit une liste de procédures et de fonctions déclarées dans la Librairie Desktools :
<page-footer>
<page-break>

Page 364
DEF LIBRARY Desktools
     DEF PROC StartUpTools(ScreenMode%,LoadPrintTools%)
     DEF PROC ShutDownTools

     DEF PROC StdAppleMenu
     DEF PROC StdEditMenu
     DEF PROC StdFileMenu(FullMenu%)
     DEF PROC DrawMenus

     DEF FN   StdWindowà(Left%,Top%,Right%,Bottom%,Titleà,DrawingProcà)
     DEF FN   StdDialog%(Msg1$,Msg2$,NumButtons%)
END LIBRARY

Le code source complet de cette librairie est dans le fichier DESKTOOLS.BAS. Les procédures et fonctions de cette librairie sont au centre de la gestion du programme GS.DEMO.BAS. En tant que tel, on va en parler du contexte du programme GS.DEMO.BAS, à travers les paragraphes suivants. Parce que les librairies TML BASIC peuvent etre utilisées dans tous programmes utilisant l'instruction LIBRARY, vous constaterez que les routines qui se trouvent dans cette librairie ont une très grande valeur, quand vous créerez votre programme Desktop. 

En fait, vous devriez créer vos propres librairies gérant les routines communes à toutes vos applications, par exemple une librairie qui gère l'impression serait surement une librairie très pratique.

L'ECRITURE D'UNE APPLICATION DESKTOP
------------------------------------
La partie principale de la plupart des programmes Desktop est constituée de seulement six appels de procédures. Ils sont les suivants :

     PROC StartUpTools(320,0)
     PROC SetUpMenus
     PROC SetUpWindows
     PROC SetUpEventTables
     PROC MainEventLoop
     PROC ShutDownTools

Les procédures StarUpTools et ShutDownTools prennent en charge le chargement, l'initialisation et la fermeture des ensembles d'outils de la toolbox, utilisés dans ce programme. Les procédures SetUpMenus et SetUpWindows sont utilisées pour créer les menus et les fenetres de l'application. La procédure SetUpEventTables rentre les lables de sous programmes dans le tableau de répartition des évenements (event dispatch table) et dans le tableau de répartition des éléments menus. Et finallement, la procédure MaintEventLoop détecte et traite les évenements.

Les six sections suivantes de ce chapitre passent en revue les opérations de chacune de ces procédures comme implémentée dans le programme GS.DEMO.BAS, ainsi que dans la librairie DESKTOOLS.BAS.
<page-footer>
<page-break>

Page 365
Alors que les exemples sont spécifiques à ces fichiers de code source, ce que l'on explique est applicable à n'importe quel programme Desktop.

LA PROCEDURE STARTUPTOOLS
-------------------------
StartUpTools est toujours la première procédure à etre éxécutée dans une applications utilisant la toolbox du IIGS. La procédure prends en charge le chargement et l'initialisation de chaque ensemble d'outils utilisé par l'application. Comme indiqué dans le chapitre 11, tous les ensembles d'outils ne résident pas dans la ROM du IIGS, mais certains se trouvent sur le disque système. Ces ensembles d'outils résidant sur disque doivent etre chargés en RAM avant de pouvoir etre utilisés.

La Toolbox du IIGS contient généralement 28 ensembles d'outils, bien que toutefois, la plupart des applications n'utilisent qu'une partie de ces outils. En fait, la plupart des applications de bureau utilisent seulement les 12 ensembles d'outils suivants :

MEMORY                   Mémoire
MISCELLANEOUS TOOLS      Outils divers
QUICKDRAW                Quickdraw
EVENT MANAGER            Gestionnaire d'évenements
WINDOW MANAGER           Gestionnaire de fenetres
CONTROL MANAGER          Gestionnaire de controle
MENU MANAGER             Gestionnaire de menu
LINE EDIT                Editeur de lignes
DIALOG MANAGER           Gestionnaire de dialogue
STANDARD FILE            Fichier standard
SCRAP MANAGER            Gestionnaire des outils couper coller etc
DESK MANAGER             Gestionnaire du bureau

Les programmes qui utilisent le Print Manager pour l'impression de documents, utilisent également les quatre ensembles d'outils suivants :

QUICKDRAW AUXILIARY      Quickdraw auxiliaire
LIST MANAGER             Gestionnaire de liste
FONT MANAGER             Gestionnaire de fonte
PRINT MANAGER            Gestionnaire d'impression

Evidemment, un programme particulier peut utiliser un sous ensemble de ces ensembles d'outils ou d'autres non listés ici, les plus notables étant les ensembles d'outils relatifs au son.

Suit le code source de la procédure StartUpTools, qui fait partie de la librairie DESKTOOLS, qui illustre  la technique pour le chargement et l'initialisation des ensembles d'outils.
<page-footer>
<page-break>

Page 366
DEF PROC StartUpTools(ScreenMode%,LoadPrintTools%)

'Sauvegarde les paramètres de démarrage en globales
svScreenMode% = ScreenMode%
svLoadPrintTools% = LoadPrintTools%

'Initialise l'écran graphique
GRAF INIT ScreenMode%
GRAF ON

'Donne un message durant le chargement et le départ des outils
_MoveTo(40,40)
_SetBackColor(0)
_SetForeColor(15)
_DrawString("Please wait, starting tools...")

'Charge les outils standards en mémoire (ainsi que les fichiers .LIB du TML)
LIBRARY LOAD "Memory"
LIBRARY LOAD "IntMath"
LIBRARY LOAD "MiscTool"
LIBRARY LOAD "QuickDraw"
LIBRARY LOAD "Event"
LIBRARY LOAD "Window"
LIBRARY LOAD "Control"
LIBRARY LOAD "Menu"
LIBRARY LOAD "LineEdit"
LIBRARY LOAD "Dialog"
LIBRARY LOAD "StdFile"
LIBRARY LOAD "Scrap"
LIBRARY LOAD "Desk"

'Charge les outils d'impression si une application les demande
IF LoadPrintTools% THEN
LIBRARY LOAD "QDAux"
LIBRARY LOAD "List"
LIBRARY LOAD "Font"
LIBRARY LOAD "Print"
ELSE
LIBRARY "QDAux"
LIBRARY "List"
LIBRARY "Font"
LIBRARY "Print"
END IF

'Demarre le memory manager
AppMemoryID% = EXFN_MMStartUp

'Attribue 10 pages de mémoire en banc 0 pour les ensembles d'outils globaux
' (1 page = 256K octets)
ToolZeroPageHà = EXFN_NewHandle(6*256,AppMemoryID%,-16379,0)
ToolZeroPagePà = VAR(ToolZeroPageHà,3)
ToolZeroPage% = EXFN_LoWord(ToolZeroPagePà)
<page-footer>
<page-break>

Page 367
'Démarre les outils standards du bureau
_MTStartUp
_WindStartUp(AppMemoryID%)
_CtlStartUp(AppMemoryID%,ToolZeroPage%)
_MenuStartUp(AppMemoryID%,ToolZeroPage%+256)
_LEStartUp(AppMemoryID%,ToolZeroPage%+512)
_DialogStartUp(AppMemoryID%)
_SFStartUp(AppMemoryID%,ToolZeroPage%+768)
_ScrapStartUp
_DeskStartUp

'Démarre les outils d'impression si ils sont demandés
IF LoadPrintTools% THEN
_QDAuxStartUp
_ListStartUp
_FMStartUp(AppMemoryID%,ToolZeroPage%+1024)
_PMStartUp(AppMemoryID%,ToolZeroPage%+1280)
END IF

'Dessine le bureau
_RefreshDeskTop(0)

'Initialise et affiche le curseur de la souris
_InitCursor
_ShowCursor
END PROC StartUpTools

La procédure StartUpTools est écrite de telle façon qu'elle peut etre utilisée par la plupart des programmes utilisant la toolbox. En tant que telle, elle a deux paramètres. Le premier paramètre indique si le Desktop doit etre initialisé dans le mode 320 ou 640, et le deuxième paramètre indique si les outils d'impression sont nécessaires.

L'instruction LIBRARY est utilisée pour charger les ensembles d'outils nécessaires en mémoire. La clause LOAD est ajoutée après le mot réservé LIBRARY pour indiquer que le code nécessaire qu chargement de l'ensemble d'outils en mémoire doit etre généré. Notez que les ensembles d'outils d'impression ne sont chargés que si le paramètre LoadPrintTools% est différent de zéro.

Après que les ensembles d'outils aient été chargés, ils doivent etre initialisés. On réalise ceci en appelant la procédure Startup pour chaque ensemble d'outils. L'ordre dans lequel les ensembles d'outils est TRES IMPORTANT. L'ordre montré dans la procédure StartUpTools est l'ordre requis pour une initialisation correcte. Si vous utilisez d'autres ensembles d'outils en plus, il devront etre démarrés après ceux listés dans la procédure StartUpTools. La plupart des procédures de Startup nécessitent le MemoryID (IDentificateur de Mémoire) de l'application et un block de mémoire pour le stockage de ses variables globales. La mémoire nécessitée pour le démarrage de plusieurs ensembles d'outils, doit etre allouée en banque 0 de la mémoire du IIGS, comme indiqué par les paramètres de la fonction NewHandle.

L'opération finale de cette procédure est de dessiner le bureau et d'afficher le curseur de la souris.
<page-footer>
<page-break>

Page 368
LA PROCEDURE SHUTDOWN
---------------------
La procésure ShutDownTools est toujours la dernière procédure appelée par une application Desktop. La procédure informe la toolbox que l'application a terminé d'utiliser chacun des ensembles d'outils qu'elle a initialisé avec la procédure StartUpTools, en désallouant la mémoire utilisée par ces ensembles d'outils et en mettant l'écran graphique hors service.

Pour signaler à la toolbox qu'une application a terminé d'utiliser un ensemble d'outils, la procédure SHUTDOWN est appelée. De nouveaun l'ordre dans lequel les ensembles d'outils sont mis hors service est TRES IMPORTANT. L'ordre doit etre l'inverse de l'ordre dans lequel les ensembles d'outils ont été démarrés. Suit la procédure ShutDownTools qui est dans la librairie Desktools.


DEF PROC ShutDownTools
'Cette procédure est utilisée pour faire un Shut Down de chacun des ensembles
'd'outils de la toolbox, démarrés par la procédure StartUpTools. TML BASIC 
'arrete l'Event Manager et le Memory Manager pour une application.

GRAF OFF

IF svLoadPrintTools% THEN
_PMShutDown
_FMShutDown
_ListShutDown
_QDAuxShutDown
END IF

_DeskShutDown
_ScrapShutDown
_SFShutDown
_DialogShutDown
_LEShutDown
_MenuShutDown
_CtlShutDown
_WindShutDown
_MTShutDown

_DisposeHandle(ToolsZeroPageHà)
END PROC ShutDownTools

La première instruction dans la procédure est GRAF OFF. Cette instruction mets hors service l'écran graphique Super HiRes et est équivalent à l'appel de la procédure Quickdraw correspondante.
<page-footer>
<page-break>

Page 369
Notez que DisposeHandle est appelé pour désallouer la mémoire avant que la routine MMShutDown soit appelée. Il est évident que cela n'aurait pas beaucoup de sens de désallouer de la mémoire (une routine du Memory Manager) après avoir mis hors service l'ensemble d'outils Memory Manager.

LA PROCEDURE SETUPMENUS
------------------------
Comme indiqué plus tot, les menus déroulants sont un des éléments d'écran fondamentaux de l'interface bureau Apple. Les menus déroulants sont faits de trois parties. Le menu barre, le menu titre et le menu élément.

Le menu barre est la surface en haut de l'écran qui contient chacun des titres menus individuels. Chaque titre menu représente un menu déroulant différent. Trois titres menus sont considérés standards et devraient présents dans chaque application Desktop. Ce sont les menus Pomme, Fichier et Edition (apple, file, edit). Ces menus devraient apparaitre dans cet ordre, comme les premiers menus dans la barre des menus. Les titres de menus spécifiques à l'application, apparaissent à droite de ces menus. Enfin, les éléments de menus sont les listes de phrases contenus dans chaque menu. Les éléments de menus correspondent aux opérations disponibles dans une application. Si un élément de menu est peu éclairé (dimmed), cela signifie que l'on ne peut pas le choisir et donc, l'opération n'est pas disponible.

Le menu Pomme contient normalement un élément de menu "A propos de ...", suivi d'une liste d'accessoires de bureau installés sur le système en cours. Le menu change en meme temps que l'utilisateur installe des NDA ou retire des NDA existants. Le menu Fichier (file) contient des opérations relatives à la création, l'ouverture, la fermeture et l'impression de documents. Au minimum, le menu File contient l'élément de menu Quit (quitter) permettant de sortir de l'application. Le menu Edition (edit) contient les opérations d'edition standard du presse papier (Clipboard). Le menu Edit devrait toujous contenir les éléments de menu Undo, Cut, Copy, Paste et Clear. Meme si l'application ne les utilise pas, ils devraient etre inclus pour les accessoires de bureau. Evidemment des opérations d'edition spécifiques à l'application telles que Select All (tout sélectionner) ou Show Clipboard (voir le presse papier) peuvent etre rajoutés au menu d'edition.

Chaque menu et élément de menu doit avoir un identificateur (identifier). L'identificateur est une valeur entière unique que le Menu Manager utilise pour identifier chaque menu et chaque élément de menu. Les identificateurs de menus sont des nombres allant de 1 à partir de la gauche en se déplacant vers la droite à travers la barre des menus. Les identificateurs des éléments de menus sont numérotés dans la gamme allant de 250 à 377. Certains identificateurs d'éléments de menus sont réservés. Le tableau 13-4 donne la liste des identificateurs d'élements de menus réservés.
<page-footer>
<page-break>

Page 370
_____________________________________________________________________________

                         Tableau 13-4
               Identificateurs des élements de menus réservés

_____________________________________________________________________________

Valeur         Signification

250            Undo  (annuler)      Valeurs réservées du Menu Manager
251            Cut   (couper)
252            Copy  (copier)
253            Paste (coller)
254            Clear (effacer)
255            Close (fermer)

256            About...  (a propos de...) Valeurs réservées Desktop TML BASIC
257            New       (nouveau)
258            Open      (ouvrir)
259            Save      (sauvegarder)
260            Save As   (Sauvegarder sous)
261            Chooser   (selecteur)
262            Page Setup(mise en page)
263            Print     (imprimer)
264            Quit      (quitter)

265            Premier identificateur spéfique à l'application

_____________________________________________________________________________


Pour créer un menu, la fonction NewMenu du Menu Manager est utilisée. Le menu est défini en utilisant un paramètre chaines de menu (Menu strings). Une chaine de menu contient le titre du menu, suivi par les noms de un ou plusieurs éléments du menu. Associé à chaque nom, on trouve un ensemble d'attributs qui définissent l'apparence des éléments, aussi bien que l'identificateur de l'élément. La chaine menu suivante est utilisée dans la procédure SdtAppleMenu dans la librairie Desktools pour définir le menu Pomme 

   MenuStr$ = ">>à/XN1/0==About.../N256/0==-N377D/0."

(NDT les signes / représentent ici la barre de fraction inversée : Backslash)

Comme vous pouvez le voir, la chaine menu est plutot difficile à déchiffrer. Le titre du menu apparaissant en premier dans la chaine menu est précédé par deux signes 'plus grand que' (>) suivis par le nom du titre du menu, ses attributs et finalement un octet zéro. Chaque élément de menu est précédé par deux symboles égal (=) suivi par le nom de l'élément de menu, ses attributs et finalement un octet zéro. Le dernier caractère dans la chaine menu doit toujours etre un point (.). En TML BASIC, le caractère nul (un octet zéro) est crée en utilisant le caractère Backslash suivi par un zéro.

<page-footer>
<page-break>

Page 371
Puisqu'il est impossible de taper le nom du symbole de la pomme en couleur, le symbole arrobad est utilisé à la place. Les lettres "'Backslash'XN1" sont l'attribut du titre du menu. De façon similaire, l'attribut pour l'élément de menu "About..." "'Backslah'N256". Les attributs dans les chaines de menu utilisent des codes spéciaux reconnus par la fonction NewMenu. Le tableau 13-5 montre les caractères d'attributs autorisés pour les chaines menus. Toute combinaison d'attribut peut etre utilisée bien que l'attribut N ou H doive toujours etre spécifié, afin de définir l'identificateur d'élément de menu.

_____________________________________________________________________________

                         Tableau 13-5
                  Attributs d'éléments de menu

_____________________________________________________________________________


Backslash      Début des caractères d'attribut spécial
*              Suivi par un caractère primaire puis par un caractère alterné
               pour etre utilisé en tant que raccourci clavier
B              Titre menu en gras
C              Suivi par un caractère pour marquer l'élément
D              Pour ombrer (dimmed) l'élément (pour ne pas l'autoriser)
H              Un indentificateur d'élément de menu héxadécimal suit
I              Le titre menu est mis en italique
N              Un identificateur de menu décimal suit (entre 256 et 3xx)
U              Souligne le menu titre
V              Place une ligne de division sous l'élément, sans utiliser un 
               élément séparé
X              Utilise la couleur de remplacement et non pas la mise en                      valeur par XOR
_____________________________________________________________________________


Parce que le Menu Manager garde des pointeurs qui pointent vers l'application à l'endroit o| les chaines menu sont rangées, il est nécessaire que les chaines menus soient rangées comme des variables globales. De plus, le stockage des variables globales ne peut pas etre déplacé durant l'éxécution d'un programme. Puisque les datas chaines sont stockées dans un réservoir de chaine qui peut etre déplacé de temps en temps, la seule alternative est de ranger les chaines menus dans un tableau de variables structuré. L'instruction SET est utilisée pour assigner une valeur chaine à un tableau structuré. Par exemple, 

   DIM AppleMenuStr!(38)
   MenuStr$ = ">>à/XN1/0==About.../N256/0==-N377D/0."
   SET(AppleMenuStr!(0)) = ^MenuStr$

Après qu'un menu ait été crée en utilisant la fonction NewMenu, on l'ajoute à la barre de menu en appelant la procédure InsertMenu. Les menus sont insérés dans la barre de menu, dans l'ordre inverse dans lequel ils apparaissent à l'écran. Après que tous les menus aient été définis, la barre de menu est dessinée. Consultez les procésures StdEditMenu, SdtFileMenu et SetUpMenus pour plus d'exemples sur la création de menus.
<page-footer>
<page-break>

Page 372

LA PROCEDURE SETUPWINDOW

les fenetres sont le 3eme élément d'ecran (screen element) fondamentales de l'interface apple desktop.Une fenetre est  une trame qui presente de l'information.les fenetre peuvent etre de toutes formes ou de toutes tailles et on peut trouver des fenetres se recouvrant sur le bureau...
Dans une fenetre il y a plusieurs elements.La figure 13.3 illsutre ceux-ci                                                                                                                                                                                                                                                 figure 13.3                                                                                 
                               
Notez que les fenetres n'ont pas neccessairement tout ces elements.Quelques fenetres (de dialogue par exemple) ont seulement une trame et un contenu ,d'autres peuvent contenir juste un titre et une barre de defilement alors que d'autres peuvent contenir chacun de ces elements...Voici une description de chacun de ces elements:
-la barre de titre contient le titre de la fenetre et peut contenir la         boite pour fermer et pour l'effet zoom.Cette zone peut aussi servir a          deplacer la fenetre
-la boite pour fermer est utilisee pour enlever la fenetre de l'ecran
-la boite zoom est uitliser pour agrandir la fenetre a sa taille maximun        et la faire revenir a sa taille initiale
<page-footer>
<page-break>

Page  372
-les barres defilements sont utilisees pour le defilement  horizontale          et verticale des donnees
-la boite d'aggrandissement est utilisee pour faire changer la taillee de      
 la fenetre
-la barre d 'information est utilise pour afficher les informations qui         se ne sont pas affectees par les barres de defilements

Pour creer une nouvelle fenetre on utilise la fonction NewWindow du Window  Manager.la fonction a un parametre unique qui decrit totalement les composant et le comportement de la fenetre. Alors q'une simple fonction est neccessaire pour creer une nouvelle fenetre son parametre est tres complexe.le parametre est un pointeur vers NewWindowParamBlk.Sa definition suit (selon l'appendice C)

-------------------------------------------------------
 DIM  aNewWindowParamblk ! (73)


element(s)    valeur         description

0..1          entier        nombre d'octet dans newwindowparamblk (=74)
2..3          entier        bitt vecteur qui decrit la fenetre
4..7          double entier pointeur vers letitre de la fenetre:stringptr
8..11         double entier application refcon
12..19        rect          taille et position du contenu quand il est zoome
20..23        double entier pointeur vers le tableau de couleur de la fenetre
                            :windowcolorTblPtr
24..25        entier        origine verticale du contenu            
26..27        entier        origine horizontale du contenu
28..29        entier        hauteur totale du document
30..31        entier        largeur totale du document
32..33        entier        hauteur max du contenu autorisé par Growwindow
34..35        entier        largeur max  --------------------------------
36..37        entier        nombre de pixels a derouler verticalement pour                                 les fleches
38..39        entier        nombre de pixels à derouler hozitontalement pour                              les fleches
40..41        entier        nombre de pixels à dérouler verticalement pour                                la page
42..43        entier        nombre de pixels à dérouler horizontalement pour                               la page
44..47        double entier bar d'information refcon
48..49        entier        hauteur de la barre d'information
50..53        double entier adresse de la procedure de definition standard de                               la fenetre:procptr
54..57        double entier adresse de la procedure de la barre d'information
58..61        double entier adresse --------------- de dessin de mise à jour                              du contenu:procptr
62..65        rect          position de depart et taille de la fenetre
66..69        double entier plan de depart de la fenetre
70..73        double entier adresse de la memoire a utiliser pour                                          l'enregistrement de la fenetre
-----------------------------------------------------------------------------
<page-footer>
<page-break>

Page 374

L'un des champs les plus important dans cette structure de donnees et le window  frame bit vector range dans les elements 2 et 3.le Bit vector est utilisé pour indiquer le type de trame de fenetre a dessiner et quels elements creer pour la fenetre.La definition pour chaque bit dans le vecteur est:

bit0       1=trame mis en valeur ,0=non mise en valeur
bit1       1=zoom en cours ,0=contraire
bit2       1=enrefistrement a ete alloue ,0=enregistrement  fournis par                  l'application
bit3       1=l'etat de controle est independant ,0=fenetre inactive a des                controles inactifs
bit4       1=fenetre avec barre d'info ,0=le contraire
bit5       1=couramment visible  ,0= invisible
bit6       1=souris appuyee dans le contenu rapporte meme quand utilisé pour              activer la fenetre
bit7       1=on peur deplacer la fenetre depuis la barre de titre,0=contraire
bit8       1=boite zoom dans le titre,0=contraire
bit9       1=growwindow et zoomwindow ne changeront pas l'origine 
bit10      1=boite d'aggrandissement dans la fenetre ,0=contraire
bit11      1=trame de la fenetre a une barre de defilement horizontale ,0=                contraire
bit12      1=trame de la fenetre a une barre de defilement vert. ,0=contraire
bit13      1=trame de fenetre de type alarme ,0=trame de fenetre de type                  document
bit14      1=close box dans barre de titre ,0=contraire
bit15      1=barre de titre  ,0=pas de barre de titre


Ainsi pour creer une fenetre tout ce qui est necccessaire est la declaration d'une variable de tableau structure et d'assigner les valeurs appropriees dans la structures en utilisant l'instruction set on trouve un exemple de ceci dans la fonction StdWindowà decdlare dans la librairie Desktools

Le paragraphe suivant examine la facon dont la fonction StdWindowà cree le block de parametre d'une nouvelle fenetre NewwindowparamBlk.En particulier la definition du bit vecteur de la trame de la fenetre  et la procedure de dessin .pour plus d'information sur Newwindowparamblk referer vous au chapitre window manager de Apple IIgs toolbox reference.

L'information suivante est utilisee pour assigner le vecteur de bit de trame de fenetre dans la fonction StdWindow:


       Set(myWind!(2))=conv%(-8800)

La fonction conv% est utilisee pour s'assurer que  l'instruction SET  assigne
  deux octets dans la variable structure   en tant qu'entier (voir la description  de SET dans le chapitre 10).la valeurb de -8800 es equivalente a la valeur binaire "1101 1101 1010 0000".ainsi en se basant sur la definition du vecteur bit donnee ci-dessus  la fenetre est definis comme suit
<page-footer>
<page-break>

Page 375


bit0    0       non mise en valeur
bit1    0       pas zoome
bit2    0       enregistrement fourni par l'application
bit3    0       fenetre inactive => controle inactiif

bit4    0       pas de barre d'info
bit5    1       couramment visible
bit6    0       souris appuyee dans le contenu non rapporte quand actif
bit7    1       barre titre=region qui permet de deplacer la fenetre

bit8    1       boite zoom dans la barre de titre
bit9    0       growwindow et zoomwindow change l'origine
bit10   1       boite d'aggrandissement dans la fenetre 
bit11   1       la trame de la fenetre  a une barre de defilement horizontale

bit12   1       "    "   "    "     "    "    "    "      "     " verticale
bit13   0       trame de fenetre de type document
bit14   1       boite de fermeture dans la boite titre
bit15   1       barre titre


 La deuxieme information qui a un interet significatif est celle qui assigne l'adresse du sous prg de dessin pour la mise a jour de la fenetre

      SET(mywind!(58))=Updateprocà

Cette instruction definit l'adresse du sous-programme qui dessine le contenu de la fenetre :par exemple la seconde fenetre dans l'exemple gsdemo.bas dessine le messsage "TML BASIC IS GREAT!" plusieurs fois.La routine suivante prend en charge l'affichage du message

    Drawwindow2:
        FORr i%=1 TO 10
           _MOVETO(i%*11+20,i%*9+10)
           _Drawstring ("TML BASIC IS GREAT!!")
        NEXT i%
        RETURN 0

Pour obtenir l'adresse de ce sous-programme son label est tout d'abord entree dans l'une des 32 dernieres entrees de l'event dispatch table en utilisant l'instruction event def. par exemple:
       EVENT DEF63,DrawWindow2
ensyte l'adresse est obtenue en utilisant la fonction EXEventà.Par exemple 
          Updateprocà=EXEVENTà(63)

Ce sous programme est alors automatiquement appelle par TASKPOLL à chaque fois que le contenu de la fenetre a besoin d'etre redessine.

<page-footer>
<page-break>Page 376
Etudiez la fonction Stdwindowà dans la librairies Desktools et les autres applications de desktop dans le sous repertoire MORE.EXAMPLES pour plus d'information concernant la creation des fenetres.

LA PROCEDURE D'INSTALATION DES TABLES D'EVENEMENT (SetUpEventTables)

la procedure SetUpEventTables prend en charge l'entree des labels,pour les sous programmes gerant les evenements ,dans l'event dispatch table et dans le menu Item Dispatch table.
Comme decrit plus tot dans la section event handling,l'affirmation TASKPOLL transfert le controle aux sous programmes de gestion des evenements automatiquement quand un evenement est detecte.Ceci est fait en indexant l'event dispatch table et le menu item dispatch table avec le type d'evenement pour localiser le sous programme de gestion des evenements.

L'application GSdemo.bas est une application de bureau simple qui se base sur TASKPOLL pour gerer la plupart des évenements de la facon standard. Souvenez-vous que ceci est fait en positionnant Taskmask en 8191 dans l'affirmation Taskpoll init.Toutefois,GSdemo.bas implemente l'evenement InGoAway et 7 elements de menu.

l'évenement Ingoaway  est implemente par le sous programme handlegoaway. Puisque l'evenement ingoaway est l'évenement 22 (voir tableau 13.1),le label handlegoaway est entre dans le 22ème element de l'Event Dispatch Table en utilisant l'affirmation Eventdef.

       EVENTDEF 22,HandleGoaway

les 7 elements de menu suivant sont implementes dans GSDEMO.BAS :about ,quit,fenetre 1,fenetre 2,rects,ovals and rounds rects.Les elements de menu sont implementes non pas en entrant un quelconque labels de sous-programmes dans l'Event Dispatch Table pour les évenements 17 (inmenubar) et 28 (inspecialmenu) mais plutot en entrant les elements de menus gerant les labels de sous-programmes dans  Menu Item dispatch Table.Ceci est fait avec l'affirmation MENUDEF.La position  d'index utilisee pour un element de menu est son identificateur d'elements de menus moins 250.Ainsi les affirmations suivantes sont utilisees pour rentrer les elements de menu gerant les labels de sous-programme dans le Menu Item dispatch Table:


MENUDEF 6,Doabout                'identificateur de menu 256
MENUDEF 14,doquit                'identificateur de menu 264
MENUDEF 15,dowindow1             'identificateur de menu 265
MENUDEF 16,dowindow2             'identificateur de menu 266
MENUDEF 17,dorects               'identificateur de menu 267
MENUDEF 18,doOvals               'identificateur de menu 268
MENUDEF 19,doRRects              'identificateur de menu 269
<page-footer>
<page-break>

Page 377

Les sous-programmes qui implementent la gestion d'evenement doivent se terminer avec la variante return 0 de l'affirmation return.Ceci parce que l'affirmation TASKPOLL a applele le sous programme et non pas l'affirmation gosub. En tant que telles, les conventions pour appeler un sous programme de gestion d'evenements sont differentes.
  
--La procedure MAINEVENTLOOP (boucle d'evenement principale)

Le coeur de toutes application controllee par des evenements est la procedure 
MainEventLoop.C'est la procedure qui prend en charge la detection d'evenements telle que souris appuyee,clavier appuye,selection de menus ,fenetre activees,etc.Quand un evenement est detecte elle donne le controle au sous programme appproprie qui gere l'evenement. Alors que ceci a l'air d'une procedure plutot complique elle est en fait tres simple.

La procedure MainEventLoop est constituee d'une boucle qui appelle repetitivement l'afffirmation taskpoll pour detecter les evenements.Quand un evenement est detecte,l'affirmation taskpoll appelle automatiquement le sous programme approprie de gestion des evenements comme specifie dans l'Event dispatch Table.Le code de source suivant est la procedure  MainEventLoop du programme GSdemo.bas
   
    DEF PROC MainEventLoop
         Quit%=0
         DO
          PROC cCheckmenus
          taskpoll -1
        until quit%
      end PROC

La premiere affirmation assigne la valeur 0 à la variable globale Quit%.la variable Quit% est mise a une valeur differente de 0 quand l'utilisateur a choisi l'element de menu quit depuis le menu file.C'est ce qui est fait dans le  sous programme DoQuit.Quand la valeur de Quit% devient diffferente de 0 on sort de la boucle.

Notez que la boucle ne contient pas un appel au sous programme Doquit, au lieu de cela elle est directement appele par l'affirmation Taskpoll quand un evenement INmenu est detecte qui choisit l'element de menu Quit.Le sous programme est automatiquement appele car la procedure SetUpeventTables a entre son label dans la Menu item dispatch table.

Comme la procedure Doquit,les autres sous programmes de gestion d'evenements dont le label se trouve dans l'Event Dispatch Table, ou dans le Menu Item Dispatch Table ,sont  automatiquement appeles par l'affirmation Taskpoll quand l'evenement lui correspondant est detecte.

Dans de nombreux cas,le sous programme de gestion evenement a besoin d'en savoir plus sur l'evenement qui est arrive.Par exemple une application qui dessine dans le contenu d'une fenetre doit savoir o| un evenement souris appuye est arrive de telle facon qu'elle puisse dessiner à l'endroit indiquer .L'information concernant l'evenement peut-etre obtenu en utlisant les fonctions TASKREC% et TASKRECà.Ces fonctions renvoit une valeur entiere ou une valeur double entiere dans la structure de donnees TaskRecord.TaskRecord est une variable interne à Tml Basic qui est declaree en tant que Event Manager Event record.La definition d'un Event record suit (d'apres l'appendice c) :
<page-footer>
<page-break>

Page 378
-----------------------------------------------------------------------------
     DIM anEventRecord!(19)

element(s)  valeur          Description

0..1        entier          (Quoi)    code de l'evenement specifiant quel                                            evenement est arrive
2..5        double entier   (message) Message d'evenement qui apporte des                                           infos supplementaires sur l'evenement
6..9        double entier   (quand)   nombre de click depuis le demarrage
10..13      Point           (o|)      Position de la souris quand l'evenement                                        est arrive
14..15      entier          (modificateurs) drapeau modificateur
16..17      double entier   (donnees Task ) donnees Task pour TaskMaster
18..19      double entier   (masque Task)   masque task pour TaskMaster
-----------------------------------------------------------------------------

Chacune des fonctions TaskRec a un parametre entier.Le parametre specifie un mot (2 octets) de decalage (offset) dans Taskrecord.Ainsi pour determiner la position de la souris pour un evenement souris appuyee ,TaskRECà(5) est appele pour envoyer le champ Point depuis Taskrecord comme un valeur double entiere.Evidemment Taskrec%(5) et Taskrec%(6) peuvent etre appeles pour envoyer les composants horizontale et verticale de Point

La signification de chaque champs depant du type de l'evenement envoye ,le tableau 13.6 donne la signification des champs Taskrecord.

-----------------------------------------------------------------------------
                   tableau 13.6
                Champs de Taskrecord
-----------------------------------------------------------------------------

What(Quoi)   indique quel type d'evenement est arrive
Message      contient une inforamtion specifique de l'evenement qui vient                  d'arrive
               Souris appuyee   numero de button dans le mot d'ordre                                          inferieur
               souris relachee  "  "  "  "  "   "   "   "   "  "                             Touche appuyee   code Ascii dans l'octet d'ordre inferieur
               touche repetition Ascii dans l'octet d'ordre inferieur
               activation        pointeur vers la fenetre  pour activer                                        (desactiver)
               mise à jour       pointeur vers la fenetre à mettre à jour
               Device driver     defini par le device driver
               application       defini par l'application
<page-footer>
<page-break>

Page 379

Quand       C'est le moment ou l'evenement est arrive.le temps est donne à                l'aide de clicks (1 click=1/60 seconde) qui se sont ecoule depuis             que vous avez boote l'Apple IIgs
OU          specifie la localisation de la souris quand l'evenement est                   arrive(donnee en coordonnes globales)
Modificateurs  donne les informations plus specifiques si approprié.Chaque                  bit de ce champs donne une info differente ,par exemple                        certains  bit indique si on a appuye sur les touches shift                     ,option,control ou pomme ouverte...
Taskdata    ce champs contient l'indentificateur de menus et l'identificateur             d'element de menus pour les elements INmenubar et INspecials.Pour              tout les autres evenements Taskmaster, ce champs contient le                   pointeur de la fenetre  ou  est arrive l'evenement (effected                  Window)
TaskMask    ce champs contient la valeur de TaskMask specifie dans                        l'affirmation TaskPOLL INIT
-----------------------------------------------------------------------------
 

  L'utilisation de la fonction Taskrec est illustree dans le sous programme handleingoaway.Quand l'utilisateur clique la souris la boite de fermeture d' une fenetre ,celle-ci est cachée.On peut rendre la fenetre à nouveau visible en choississant son nom dans le menu fenetre.Quand Taskpoll detecte un evenement ingoaway le sous programme handleigoaway  est appele pour que celui ci determine quel fenetre fermer il doit examiner le champs taskdata de Taskrecord.Par exemple:

       Handleingoaway
       thewindowà = Taskrecà(8)
       _hidewindow(thewindowà)
       RETURN 0

La boucle d'evenements principale peut contenir d'autres operations qui maintiennent l'etat en cours du bureau (Desktop).Par exemple le programme GSdemo.bas autorise ou interdit les elements du menu edit en fonction du type de la fenetre la plus superieur (topmost) .Les fenetres gsdemo.bas ne supportent l'edition des operations trouvees dans le menu Edit.Ainsi elle devrait etre interdite pour communiquer a l'utilisateur qu'elles n'ont pas d'effets.Toutefois si la fenetre d'un accessoire de bureau est topmost  les operations d'edition peuvent etre supportees et ainsi autorisees.La boucle d'evenements principale contient un appel a la procedure checkmenus qui verifie la fenetre topmost et autorise ou interdit les evenements du menu edit de facon appropries.La plupart des applications desktop devraient implementer la procedure checkmenus et suivant la nature de l'application d'autres operations pourraient etre appropriées ou non.

<page-footer>
<page-break>

Page 380

--RESUME

Ce chapitre a introduit les principes d'application de bureau bien conçus qui suivent les directives de l'interface Apple.De plus,les techniques pour l'ecriture de programmes controlles par des evenements qui utilisent la boite à outils de l'apple IIgs ont été vu à travers l'application GSDEMO.BAS.
D'autres d'applications de bureau peuvent etre trouvees dans le sous repertoire MORE.EXAMPLES.Ces exemples illustrent un peu plus les techniques d'ecriture de programme controlles par des evenements.

Fin du chapitre 13




Page 383